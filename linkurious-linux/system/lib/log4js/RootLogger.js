/**
 * LINKURIOUS CONFIDENTIAL
 * Copyright Linkurious SAS 2012 - 2018
 *
 * - Created on 2016-10-26.
 */
'use strict';

// internal libs
const path = require('path');

// external libs
const fs = require('fs-extra');
const winston = require('winston');

// locals
const CustomLogger = require('./CustomLogger');
const Levels = require('./Levels');

const ANSI_COLOR_RE = /\u001b\[(\d+(;\d+)*)?m/g;
class FileTransport extends winston.transports.File {
  log(level, msg, meta, callback) {
    msg = ('' + msg).replace(ANSI_COLOR_RE, '');
    if (typeof meta === 'object' && meta) {
      meta.originalMessage = meta.message;
    }
    return super.log(level, msg, meta, callback);
  }
}

class RootLogger {

  /**
   * @param {object}  options
   * @param {string}  options.logLevel       The default log level
   * @param {boolean} options.addPrefix      Whether to prepend the packageId to each logged line
   * @param {string}  options.logFileName    Name of the log files (used as prefix)
   * @param {string}  options.projectRoot    Absolute path of the application root
   * @param {string}  options.logDirPath     Absolute directory path to write the log files in
   * @param {object}  [options.customLevels] Custom log levels by package prefix
   */
  constructor(options) {
    // clone options
    //this.options = JSON.parse(JSON.stringify(options));
    this.options = options;

    if (!this.options.customLevels) {
      this.options.customLevels = {};
    }

    // target directory for log files
    const dirPath = this.options.logDirPath;
    fs.ensureDirSync(dirPath);

    const filePrefix = this.options.logFileName;
    // regular log file
    const logFilePath = path.resolve(dirPath, filePrefix + '.log');
    fs.ensureFileSync(logFilePath);

    // exceptions log file
    const exceptionLogFilePath = path.resolve(dirPath, filePrefix + '.exceptions.log');
    fs.ensureFileSync(exceptionLogFilePath);

    this._logger = new (winston.Logger)({
      levels: Levels,
      colors: {
        silly: 'grey',
        debug: 'white',
        info: 'green',
        warn: 'yellow',
        error: 'red'
      },
      transports: [
        // console appender
        new (winston.transports.Console)({
          level: 'silly',
          colorize: true,
          handleExceptions: true,
          prettyPrint: true,
          stderrLevels: ['error']
        }),

        // regular log file appender
        // @ts-ignore too old to fix (log4js)
        new FileTransport({
          filename: logFilePath,
          level: 'silly',
          timestamp: true,
          maxsize: 5 * 1024 * 1024, // 5MB
          maxFiles: 10
        })
      ],
      exceptionHandlers: [
        // exceptions log file appender
        // @ts-ignore too old to fix (log4js)
        new FileTransport({
          filename: exceptionLogFilePath,
          timestamp: true,
          maxsize: 5 * 1024 * 1024, // 5MB
          maxFiles: 10
        })
      ]
    });
  }

  silly() { this._logger.silly.apply(this._logger, arguments); }
  debug() { this._logger.debug.apply(this._logger, arguments); }
  info() { this._logger.info.apply(this._logger, arguments); }
  warn() { this._logger.warn.apply(this._logger, arguments); }
  error() { this._logger.error.apply(this._logger, arguments); }

  /**
   * Create a custom logger for a given file.
   *
   * @param {string} targetFile `__filename` of the file requesting the custom logger
   * @param {string} [subPackage] An additional package to append to the chain generated by `targetFile`
   * @returns {CustomLogger}
   */
  createCustomLogger(targetFile, subPackage) {

    // cleanup `__filename` to generate the "packageId"
    const packageChain = targetFile
      .replace(/\.js$/, '')
      .replace(this.options.projectRoot, '')
      .split(path.sep);
    if (packageChain[0] === '') { packageChain.shift(); }
    if (subPackage) {
      packageChain.push(subPackage);
    }

    const loggerLevel = this.getLogLevel(packageChain) || this.options.logLevel;
    return new CustomLogger(this, loggerLevel, packageChain, this.options.addPrefix);
  }

  /**
   * Get the custom log level for a package (if any).
   *
   * @param {string[]} packageChain
   * @returns {string | undefined}
   */
  getLogLevel(packageChain) {
    const packageId = packageChain.join('.');

    // get matching prefixes
    const matches = [];
    for (const packagePrefix of Object.keys(this.options.customLevels)) {
      // if the current package starts with the given package prefix, it's a match
      if (packageId.indexOf(packagePrefix) === 0) {
        matches.push(packagePrefix);
      }
    }

    // no matching prefix: no custom log level
    if (matches.length === 0) {
      return undefined;
    }

    // resolve log level for the most specific (longest) prefix
    const mostSpecificPrefix = matches.sort((a, b) => b.length - a.length)[0];
    return this.options.customLevels[mostSpecificPrefix];
  }
}

module.exports = RootLogger;
